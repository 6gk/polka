#  ~/etc/sh/aliases

command -v shlib >/dev/null && . shlib

alias td="transmission-daemon"

alias sy="systemctl --user"
alias ss="sudo systemctl"

# package manager
# github.com/willeccles/cpm
alias \
	i="cpm i"  \
	r="cpm r"  \
	s="cpm s"  \
	in="cpm I" \
	up="cpm U" \
	ni="nix-env -iA"

# git
alias \
	ga="git add"   \
	gd="git diff"  \
	gr="git reset" \
	gaa="git add -A"

alias \
	gc="git commit"    \
	gcm="git commit -m" \
	gca="git commit --amend"

alias \
	gp="git push"  \
	gpf="git push -f"

alias gds="git diff --staged"

# short and informative git log
alias gl="git log --all --decorate --oneline --graph"

# standard utils
alias ls="ls -h --group-directories-first --color=auto"
alias grep="grep --color=auto"

alias \
	rm="del"   \
	g="grep -i" \
	s1="sleep 1" \
	s2="sleep 2" \
	s3="sleep 3" \
	s4="sleep 4" \
	fuck="pkill -9"

calc() { echo "scale=5; $*" | bc; }

# elapsed time
et() { ps -o command,etime $(pgrep "$1"); }

#
#  files/dirs
#

# file shortcuts
v=${XDG_CONFIG_HOME:=~/.config}/sh/sc.sh
[ -e "$v" ] && . "$v"

# drag and drop
alias q="dragon --and-exit"

# copy image
alias ci="xclip -selection clipboard -t image/png"

# rough find
f() { find "${2:-.}" -iname "*$1*"; }
# exact find
F() { find "${2:-.}" -name "$1"; }

# backup
# zstd decompresses fast
bk() { tar -I zstd -cvf "${1%/}_$(date -Id).tar.zst" "$1"; }

alias e="atool -x"
c() { tar -czvf "${1##*/}.tar.gz" "$@"; }

d() {
	unset asda vid img act

	for arg; do
	# check if argument is an exact filename, or at the start/end/middle
	# of a filename, in that order
	for i in "$arg" "$arg"* *"$arg" *"$arg"*; do
		[[ -e "$i" ]] || continue

		case $(file -ib "$i") in
			# add to array then call the command as to use the native album
			# feature in mpv/feh instead of making multiple windows
			video*|image/gif*) vid+=("$i");;
			image*)            img+=("$i");;

			text*)      cat "$i";;
			*)  break;;
		esac

		act=nonzero
		break
	done
	done

	[ "$img" ] && im "${img[@]}"
	[ "$vid" ] && mpv "${vid[@]}" --loop

	[ "$act" ] || return 1
}

# quickly view contents of file based on term height
t() {
	[ -f "$1" ] || return
	var=$(wc -l "$1")
	if [ "${var%% *}" -ge $((LINES-4)) ]; then
		less "$1"
	else
		cat "$1"
	fi
}

v() {
	# edit file based on write perms
	if [ ! "$1" ] || eq "$1" '-*' || [ -w "$1" ] || [ -w "$(dirname "$1")" ] || eq "$1" "http*"; then
		$EDITOR "$@"
	else
		sudo -E $EDITOR "$@"
	fi

	# reset cursor
	printf '\e[4 q'
}

#
#  media
#

# convert to gif
cgif() {
	eval "$(ffprobe -v quiet -show_streams "$1" | grep '^[wh]')"

	[ "$width" -gt "1000" ] &&
		echo "video width ($width) greater than 1000, shrinking" &&
		width=1000

	f="fps=15,scale=$width:-1:flags=lanczos"

	echo "Generating the palette"
	ffmpeg -i "$1" -vf "$f,palettegen" -y "/tmp/palette.png" -loglevel error

	echo "Generating the gif"
	ffmpeg -i "$1" -i "/tmp/palette.png" -lavfi "$f [x]; [x][1:v] paletteuse" \
		-y "${1%.*}.gif" -loglevel error
}

# lower res to 720p
c720() {
	ffmpeg -y -i "$1" -b:v 4M \
		-r 30 \
		-c:v h264_nvenc    \
		-vf "scale=1280:-1" \
	  "${1%.*}-720.mp4"
}

# combine images vertically
comb() {
	montage "$@" -geometry +0+0 -tile 1x output.png
}


#
#  other
#

blocks() {
	for i in 4 10; do
		printf "\e[$i%sm   \e[m"  {1..7}
		echo
	done
}

notthing() {
	for i in critical normal low; do
		notify-send -t 40000 -u "$i"   "  $i  â€‹"
	done
}

# window titles
#precmd() {
#	printf "\e[4 q\033k %s \033\\" "${PWD//$HOME/~}"
#}
#preexec() {
#	a="${3//$HOME/~}"
#	printf "\033k %s \033\\" "${a//\"}"
#}

# vim: ft=sh
